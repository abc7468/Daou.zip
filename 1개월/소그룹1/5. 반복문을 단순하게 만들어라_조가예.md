> 1개월_3주차(2023/03/26)

### 화살표 함수로 반복문을 단순하게 만들어라

-   ES6 문법 이전의 함수는 장황하다.
    
    -   명시적으로 `function` 키워드를 써야 하고
    -   인수를 감싸는 `()` 를 써야 하고
    -   함수 몸체를 보여주기 위한 `{}` 를 써야 하고
    -   `return` 문을 사용해야 한다.
-   화살표 함수는 함수가 장황해지는 문제를 해결해서 함수 작성을 간결하고 짧게 만들어 준다.
    
-   `=>` 두꺼운 화살표로 함수라는 것을 알려주기만 하고 몇 가지 규칙을 지키면 된다.
    
-   Before
    
    ```jsx
    function capitalize(name) {
    	return name[0].toUpperCase() + name.slice(1);
    }
    ```
    
-   After
    
    ```jsx
    const capitalize = name => {
    	return name[0].toUpperCase() + name.slice(1);
    }
    ```
    
-   매개변수가 없거나 2개 이상일 때는 인자에 괄호를 써줘야 한다.
    
-   자바스크립트에서는 함수를 다른 함수에 인수로 전달할 수 있다. 함수는 그저 다른 형태의 데이터일 뿐이다.
    
-   함수를 다른 함수에 인수에 전달할 때, 화살표 함수의 탁월함을 볼 수 있다.
    
-   Before
    
    ```jsx
    applyCustomGreeting('mark', function (name) {
    	return `안녕, ${name}!`;
    }
    ```
    
-   After
    
    ```jsx
    applyCustomGreeting('mark', name => `안녕, ${name}!`;)
    ```
    

### 배열 메서드로 반복문을 짧게 작성하라

-   map()
    -   형태는 바꿀 수 있지만 길이는 유지. 배열 반환
-   sort()
    -   형태나 길이는 변경되지 않고 순서만 변경
-   filter()
    -   길이를 변경하지만 형태는 유지. 조건에 맞는 배열을 반환.
-   find()
    -   한 개의 데이터만 반환. 형태는 유지.
-   forEach()
    -   형태를 이용하지만 아무것도 반환하지 않음.
-   reduce()
    -   길이와 형태를 바꿀 수 있고 무엇이든 처리할 수 있음.
-   배열 메서드는 연결해서 사용할 수 있음.
    -   ex) 배열.map().filter()

### map() 메서드로 비슷한 길이의 배열을 생성하라

-   맵 함수는 입력한 배열의 정보 중 한 조각을 받아 새로운 값을 반환한다.
-   떄로는 정보의 일부를 반환하기도 하며 정보를 변형해서 새로운 값을 반환하기도 한다.

### filter()와 find()로 데이터의 부분집합을 생성하라

<filter>

-   filter 메서드는 map과는 다르게 배열에 있는 정보를 변경하지 않는다.
-   반환되는 배열의 길이를 줄일 뿐이다.
-   각각의 배열 항목을 전달받아 조건에 일치하는 항목만 배열로 반환한다.
-   원래 배열의 순서도 그대로 유지한다.
-   항상 배열을 반환하며, 조건에 일치하는 항목이 없는 경우에도 배열을 반환함.
-   그래서 몇개나 만족하는 지 확인하려면 length 속성을 통해 파악할 수 있음.

<find>

-   배열에서 찾으려는 항목이 하나인 것을 알고 있는 경우나
-   조건에 일치하는 첫 번째 항목이 필요한 경우에 유용함.
-   이는 공통 조건에 부합하는 항목의 수가 클 경우, 성능을 최적화할 수 있는 방법이기도 함.
    -   ex) 반복문에서 break 를 쓰는 경우에 사용하기 적합함.
-   하지만 반환값을 확신할 수 없다는 점이 단점이다.
-   조건에 맞는 항목이 없을 때, 빈 배열이 아닌 undefined를 반환한다.
-   여기서 단락평가(vlaue || default)를 이용하면 기본값을 추가해서 활용할 수 있다.

### forEach()로 동일한 동작을 적용하라

-   입력 배열을 전혀 변경하지 않는다.
-   모든 항목에 동일한 동작을 수행한다.
-   다른 메서드들 처럼 코드를 단순하게 만드는 데 장점이 있지는 않다.
-   예측 가능하면서도 다른 배열 메서드와 같이 작동해 함께 연결할 수 있기 때문에 가치가 있다.
-   함수 외부에 영향(부수효과)을 준다.
-   따라서 함수의 유효범위를 벗어나는 작업이 필요한 경우 사용하기 적합하다.

### 체이닝으로 메서드를 연결하라

-   체이닝 : 값을 다시 할당하지 않고 반환된 객체에 메서드를 즉시 즉시 호출하는 것
-   메서드의 결과값을 매번 변수에 할당할 필요가 없음.
-   결과값에 직접 메서드를 호출해, 중간 단계를 제거할 수 있음.
-   각 배열 메서드가 고유의 작업을 수행하기 때문에 코드를 한눈에 이해할 수 있다.
-   단점은 새로운 메서드를 호출할 때마다 반환된 배열 전체를 다시 반복한다는 점.
-   약간의 성능 향상보다 가독성이 중요한 경우도 있다.
-   마지막 문장까지 세미콜론이 없는 것을 확인해야 한다.
-   각 메서드의 순서를 지켜야 한다.

### reduce()로 배열 데이터를 변환하라

-   배열메서드가 훌륭한 이유는 콜백 함수를 이해하기 전에 결과값을 한눈에 예측할 수 있기 때문.
-   특정 항목의 수가 필요하거나 배열을 객체처럼 다른 형태의 자료구조로 변환해야 하는 경우에 사용.
-   배열의 길이와 데이터 형태 모두 변경할 수 있다. 반드시 배열을 반환할 필요도 없다.
-   콜백함수에서 항상 누적된 값을 반환해야 한다.
-   함수의 끝에 데이터 초깃값을 지정해두고 사용한다.

### for…in 문과 for…of 문으로 반복문을 정리하라

-   배열 메서드로 충분한 결과값을 얻어낼 수 없을 땐 기존 반복문을 사용해야 한다.
-   예측가능성이 줄어드는 문제는 있다.