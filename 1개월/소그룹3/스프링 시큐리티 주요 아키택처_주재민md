# 스프링 시큐리티 주요 아키택처

## 위임 필터 및 필터 빈 초기화 - DelegatingProxyChain, FilterChainProxy

---

### DelegatingFilterProxy

![Untitled](https://user-images.githubusercontent.com/57485510/226492664-9587139f-77c5-44c4-bd55-130fc3691233.png)

서블릿필터는 스프링에서 정의된 빈을 주입해서 사용할 수 없다. (빈을 사용할 수 없는 것이지, 필터가 동작하지 않는 거은 아님)하지만, `DelegatingFilterProxy`는 특정 이름의 빈을 찾아 그 빈에게 요청을 위임한다.

- `springSecurityFilterChain` 이름으로 생성된 빈을 `ApplicationContext`에서 찾아 요청을 위임
- 실제 보안처리를 하지 않음 → `DelegatingFilterProxy`는 서블릿 필터라고 보면 된다.
- 즉, `DelegatingFilterProxy`는 서블릿 필터역할이고, 제일 먼저 요청을 받아서 스프링에서 관리하는 필터에 요청을 위임
    - 다시 말하지만, [ 서블릿 필터 ← 스프링 빈 주입 ]이 안된다. 그 역할을 `DelegatingFilterProxy`가 하는 것

요약

1. 요청을 서블핏필터 대신 위임
2. `springScurityFilterChain`을 찾음

### FilterChainProxy

`springSecurityFilterChain`의 이름으로 생성되는 빈으로써, 실제로 `DelegatingFilterProxy`로부터 요청을 위임받음

- 실제 보안 처리
- 시큐리티 초기화 시 생성된는 “필터”들을 관리하고 제어
    1. 기본적으로 생성되는 필터
    2. `Configuration` 클래스에 API 추가하여 생성되는 필터
- 요청을 → 필터순 → 으로 처리
- 사용자 정의 필터를 생성 후, 기존의 필터 before Or after에 추가 가능
- 성공 조건: 마지막 필터까지 인증 및 인가 예외가 발생하지 않아야 함
    
    

![Untitled 1](https://user-images.githubusercontent.com/57485510/226492578-bdc7eeab-2155-4d1e-a2b2-28f58c94a698.png)

← 왼쪽이 서블릿 컨테이너 위치에서 동작하고  |  오른쪽이 스프링 컨테이너에서 동작한다 →

## 필터 초기화와 다중 보안 설정

---

### 필터 초기화와 다중 설정 클래스

![Untitled 2](https://user-images.githubusercontent.com/57485510/226492584-7a6c3c66-b55f-4b7a-945e-5bffe328b859.png)

사용자 정의 보안 API를 설정한 클래스가 2개 있다

- 보안 기능은 2개가 각각 동작
- 설정 별로 `RequestMatcher` 설정
    - admin ← (`http.antMatcher(”/admin”**)` )은 왼쪽으로, 나머지는 오른쪽으로
- 설정 클래스 별로 필터 생성
- `FilterChainProxy`가 각 필터 들을 가지고 있고, {요청이 오면 → `RequestMatcher`와 매칭 된 필터가 작동}

## 인증 개념 이해 - Authentication

---

### 인증 - Authentication

사용자의 인증 정보를 저장하는 토큰 개념 → 기본적으로 id, password를 담아 전달하면 인증 검증

- 인증 결과: User객체, 권한 정보 → Security
- 구조
    1. `Principal`: 사용자 아이디 혹은 User객체를 저장
    2. `credentials`: 사용자 비밀번호
    3. `authories`: 인증된 사용자의 권한 목록
    4. `details`: 인증 부가 정보
    5. `Authenticated`: 인증 여부

### 인증 FLOW

![Untitled 3](https://user-images.githubusercontent.com/57485510/226492586-510457bd-e6b3-425a-b17d-42ab395f8a66.png)

- `Authentication`객체가 `UsernamePasswordAuthenticationFilter` 결과 1차적으로 저장됨
- `AuthenticationManager`: 인증정보를 가지고 인증처리를 진행 (→ 인증 실패 시는 exception)
    - 인증 성공시, `Authentication` 객체를 2차로 다시 만든다
    - `Credentials`에 패스워드를 담지만, 비워두기도 한다
    - `Authorities`를 채운다
    - 이 과정을 거쳐야 `Authenticated`가 True로 인증되었음을 나타낸다

> `Pirncipal` 객체는 spring에 있는 기능이 아니다. java에 있는 기능
> 

- 인증 결과를 `UsernamePasswordAuthenticationToken`에 담는다
    - 2개의 생성자가 있다 - (principal, credentials) , (principal, credential, grantedAuthority )
- 해당 클래스는 `Authentication` 인터페이스를 구현
- 인증 필터에서, 인증 결과(`authResult`) ⇒ SecurityContext에 저장한다(`setAuthentication`)
- 

## 인증 저장소 - SecurityContextHolder, SecurityContext

---

### SecurityContext

Authentication 객체가 저장되는 보관소로 필요하면 어디서 언제든 Authentication객체를 꺼내쓸 수 있음

- ThreadLocal에 저장 → 아무곳에서나 참조가 가능하도록 설계
- 인증 완료되면 HttpSession에 저장 → Application 전반에 걸쳐 전역적인 참조가 가능

### SecurityContextHolder

SecurityContext 객체를 저장하는 방식

- `MODE_THREADLOCAL`: 스레드 당 SecurityContext객체를 할당 ← default
- `MODE_INHERITABLETHREADLOCAL`:  메인 스레드 와 자식 스레드에 관하여 동일한 SecurityContext를 유지
    - 프로세스 생성 → 메인 스레드 생성
    - 메인 스레드 → 자식 스레드 들을 생성
    - 자식과 메인 스레드가 서로 동일한 SecurityContext를 활용하도록 만듬
- `MODE_GLOBAL`: 응용 프로그램에서 단 하나의 SecurityContext를 저장
    
    → 아래도 갈수록 범위가 커진다고 보면 된다
    

`SecurityContext` 정보를 Clear도 가능

### SecurityContextHolder Flow

![Untitled 4](https://user-images.githubusercontent.com/57485510/226492642-be3b7093-9899-414b-ae12-3113d54747b6.png)

- 인증실패 하면, `SecurityContextHolder.clearContext()`를 수행
- 인증을 성공하면 결과적으로 `HttpSession`에 저장된다

## 인증 저장소 필터 - SecurityContextPersistenceFilter

---

### SecurityContextPersistenceFilter

`SecurityContext`객체의 생성, 저장, 조회하는 기능

- 익명 사용자
    - 새로운 `SecurityContext`객체 생성 → `SecurityContextHolder`에 저장
    - `AnonymousAuthenticationFilter`에서 →  `AnonymousAuthenticationToken`객체를 `SecurityContext`에 저장
- 인증 시
    - 새로운 `SecurityContext`객체 생성 → `SecurityContextHolder`에 저장
    - `UsernameAuthenticationFilter`에서 → `UsernamePasswordAuthentication` 객체를 `SecurityContext`에 저장
    - 인증과정이 성공적으로 끝날 때, → `Session`에 `SecurityContext`를 저장
- 인증 후
    - `Session`에서 `SecurityContext` 꺼내서  → `SecurityContextHolder`에 저장
    - `SecurityContext`안에 `Authentication` 객체가 존재하면 인증이 유지된다

### SecurityContextPersistenceFilter Flow

![Untitled 5](https://user-images.githubusercontent.com/57485510/226492646-2456a17d-c278-4d5a-96b5-dc5019f78c2b.png)

- 매 요청에서 HttpSecurityContextRepository를 통해 사용자 인증 전/후를 필터링한다
- 인증 전이면, SecurityContextHolder안에 새로운 SecurityContext를 생성하고 → AuthFilter로 보내서 인증을 처리
    - 인증 결과를 SecurityContextHolder안에 있던 SecurityContext에 저장
- 인증 후에는 Session에 있는 SecurityContext를 활용

요약

- 인증 전에 요청으로 들어온 (익명사용자를 허용하면) 인증안한 유저의 SecurityContext정보를 SecurityContextHolder에 저장된다
- 인증 전에 요청으로 들어온 인증 처리를 원하는 유저가 인증 처리되면 SecurityContext정보를 SecurityContextHolder에 저장된다
- 인증 후에는 요청으로 들어오면 Session에 저장된 SecurityContext 정보를 SecurityContextHolder에 저장한다

## 인증 흐름 이해 - Authentication Flow

---

![Untitled 6](https://user-images.githubusercontent.com/57485510/226492649-3af693ad-b833-4654-99eb-4883a9335b53.png)

- `AuthenticationManager`는 실제 인증 처리를 하지 않음 → 적절한! `AuthenticationProvider`를 찾아서 인증 처리를 위임
    - 적절한 `AuthenticationProvider`를 찾는다는 것
- `AuthenticationProvider`가 그 뒤에서 인증 처리를 하고 인증 결과를 담은 `Authentication`객체를
→ `AuthenticationManager`에게 전달
- `AuthenticationManager`를 `UsernamePasswordAuthenticationFilter`에게 줘야 `SecurityContext`에 저장된다

### 실제 처리과정에서

- `DaoAuthenticationProvider` : Form인증을 제어하는 녀석
    - username/password  → `UserDetailsService`에서 인증

## 인증 관리자 - AuthenticationManager

---

### AuthenticationManager

![Untitled 7](https://user-images.githubusercontent.com/57485510/226492651-c7dbf122-13a6-489b-9fc0-608d56e88c2a.png)

Filter로부터 실제로 인증처리를 처음으로 전달받는 객체로, `AuthenticationProvider` 목록을 찾아서 인증 처리 요건에 맞는 AuthenticationProvider를 찾아 인증처리를 위임한다

- 부모 `ProviderManager`를 설정하여 `AuthenticationProvider`를 계속 탐색 가능하다
- 여러가지 인증 방식(Form, RememberMe….)으로 들어오면, 그에 맞는 Provider를 `ProviderManager`가 찾아낸다
    - 이런 상황도 나올 수 있다
        1. OAuth인증 요청 
        2. 자식 `ProviderManager`가 가진 Provider목록에서 찾기 → 자신한테 없음!
        3. 자식 속성으로 있는 부모 `ProviderManager`를 탐색 → 찾기 → 있음
        4. 찾은 Provider에 인증처리를 맡김
    

### 요약

- `AuthenticationProvider`를 `AuthenticationMangerBuilder`로 목록에 추가
- `AuthenticationProvider`와 부모 `ProviderManger`까지 담는 `ProviderManager` 객체를 만듬
- 요청이 들어옴 → Filter → `AuthenticationManager`에게 인증 처리 위임
- `AuthenticationManager`에 있는 `ProviderManager`에게 해당 인증에 맞는 `AuthenctionProvider`를 찾으라고 보냄
- `AuthenticationProvider`를 찾고 없으면 부모 `ProviderManger`에서 찾아 인증처리 후 결과를 `AuthenticationManager`에게 전달

## 인증 처리자 - AuthenticationProvider

---

### AuthenticationProvider

![Untitled 8](https://user-images.githubusercontent.com/57485510/226492653-1429f059-87a1-45c7-b374-eb48411f46a5.png)

- authenticate는 사용자 계정이나 패스워드, 추가 검증을 진행한다.
    - 인증이 최종적으로 통과하면 `Authentication`객체에 User객체와 `Authorities`(권한)객체를 담은 후
    → `AuthenticationManager`객체에 넘긴다
- supports는 현재 인증처리를 할 수 있는 Provider의 기준, 조건에 관련된 처리를 담당

## 인가 개념 및 필터 이해 - Authorization, FilterSecurityInterceptor

---

### Authorization

인가 = 사용자가 할 수 있는 것들

인증 = 사용자가 맞는지 확인하는 것

- 인증과 인가 분류
    
    ![Untitled 9](https://user-images.githubusercontent.com/57485510/226492655-8b9feaf2-4046-48ae-b61e-acded4f33594.png)
    

스프링 시큐리티가 지원하는 3가지 권한 계층

- 웹 계층
- 서비스 계층
- 도메인 계층 ← Access Control List, 접근제어 목록
    - 객체 단위 레벨 보안

### FilterSecurityInterceptor

인가 처리를 담당하는 필터로, 인증처리가 끝나면 해당 요청에 권한을 보고 승인/거부 여부를 최종 결정

- 인증 객체 없이 보호자원에 접근을 시도, 즉 인증 없이 접근 → `AuthenticationException` 던짐
- 인증 후 접근 권한이 존재하지 않는 경우 → `AccessDeniedException` 던짐
- 권한 제어 방식 중, HTTP 자원의 보안을 처리하는 필터

실제 권한을 처리하는 녀석은 `AccessDecisionManager`에게 맡김

### FilterSecurityInterceptor Flow

![Untitled 10](https://user-images.githubusercontent.com/57485510/226492657-048891c6-3822-4780-bab7-4510d5d24a8e.png)

- `SecurityMetaSource` : 예시를 들자면, [ /user요청에는 ROLE_USER권한이 필요하다 ] 라는 정보를 가지고 오는 녀석이다
    - 그 URL에 권한이 할당된 것이 없다 → 권한이 필요하지 않다 → 자원 접근을 검사 없이 허용
    - 검사가 필요하다 → `AccessDecisionManager`에게 최종 심의를 결정하도록 전달
- `AccessDecisionManager`:  최종 심의 결정자이고, 실제 심의 요청은 다른 녀석이 함
    - `AccessDecisionVoter` 심의요청을 받아, 최종 결정을 `AccessDecisionManager`에게 넘김

### 실제 처리 로직 필기

`FilterChainProxy`(filter목록) 
→ 쭉 마지막에 `FilterSecurityInterceptor`(인가 처리) 
→ `AbstractSecurityInterceptor`(`FilterSecurityInterceptor`부모 클래스임) 

{ 위 설명에서 `SecurityMetaSource`에서 메타데이터를 가지고 오는 역할, 인증 처리 여부 검사

→ `AffirmativeBased` (`AccessDecisionVoter`를 사용)
← 처리 결과 리턴 or 예외를 던짐

→ `ExceptionTranslationFilter`(예외를 던지는 경우 처리 담당)

> `AbstractSecurityInterceptor`는 `MethodSecurityInterceptor`도 자식으로 있는데, 필터는 아니고 인터셉터로 AOP 기반으로 동작한다
> 

## 인가 결정 심의 - AccessDecisionManager, AccessDecisionVoter

---

### AccessDecisionManager

인증 정보, 요청 정보, 권한 정보를 이용 → 사용자의 자원접근 허용/거부를 결정하는 최종 주체

- 여러 개의 Voter들을 가질 수 있다. 이 Voter들로부터 접근에 대한 처리 결과를 리턴받아 판단 및 결정을 내린다.
- 최종 접근 거부는 예외로 이어진다

접근 결정 3가지 유형

- `AffirmativeBased`: 여러개 Voter 객체 중에 하나라도 접근 허가를 내리면 → 접근 허가
- `ConsensusBased`: 다수표에 의한 최종 결정 판단한다. 동수라면? 기본 = 접근 허가(allowEqualGrantedDeniedDecisions = false ← 접근 거부)
- `unanimousBased`: 모든 Voter가 만장일치로 접근 승인 시 → 접근 허가

### AccessDecisionVoter

판단을 심사하는 심사위원 역할

Voter가 권한부여 시 판단하는 자료 3가지

- `Authentication` - 인증 정보
- `FilterInvocation` - 요청 정보 (ex: `antMatcher(”/user”)`)
- `ConfigAttributes` - 권한 정보 (ex: `hasRole(”USER”)`)

결정을 내린 결과 방식

- `ACCESS_GRANTED`: 접근 허용 (1)
- `ACCESS_DENIED`: 접근 거부 (-1)
- `ACCESS_ABSTAIN`: 접근 기권 (0)
    - 해당 결정은 요청에 대한 결정을 내릴 수 없다고 판단되면 나온다

### AccessDecisionManager, AccessDecisionVoter Flow

![Untitled 11](https://user-images.githubusercontent.com/57485510/226492658-b40390f0-1106-4766-b56c-0da1bd8ec557.png)

### 실제 처리 과정

- `AbstractSecurityInterceptor`(`decide()`에 인증객체, 권한정보, 요청정보) → `AccessDecisionManager`에 전달
- `AccessDecisionManger`는 Voter들을 불러서 권한에 대한 처리를 전달 ← 전달받은 인증객체, 권한정보, 요청정보 그대로 전달
- Voter들이 인가를 처리하여 결과를 `AccessDecisionManger`에게 전달

## 스프링 시큐리티 필터 및 아키텍처 정리

---

![Untitled 12](https://user-images.githubusercontent.com/57485510/226492659-859fda18-df55-4bd7-a2a2-100150850889.png)

### 초기화

1. 시큐리티 초기화
    - 이 부분은 사실 버전3.0.0으로 오면서 사용법에 변화가 있다 → `WebSecurityConfigurerAdapter`가 `deprecated`된 부분
    - Bean으로 SecurityFilterChain 을 등록하면서 → 클래스 별로 나눌 필요가 없다
    - WebSecurity Bean객체를 filter로 전달한다고 하지만, `SecurityFilterChain`이 빈으로 생성된다(수업과 다른 내용)
    - 생성자로 filters(목록)을 `FilterChainProxy`으로 전달하여 가지고 있는다
2. `DelegatingFilterProxy`
    - 특정한 이름(springSecurityFilterChain)의 빈을 찾는다
    - 요청이 들어오면 그 빈에게 위임한다

### 요청으로 인증 처리

1. Filter들이 Chain으로 연결되어서, 순서대로 처리된다( DelegatingFilterProxy → FilterChainProxy → SecurityContextPersistenceFilter)
2. `SecurityContextPersistenceFilter`
    - `HttpSessionSecurityContextRepository`는 `SecurityContext`를 생성해서 `Session`에 저장 및 조회 가능하도록
    - `loadContext`로 세션에 저장된 이력을 체크
3. `LogoutFilter`
    - 로그아웃 요청에만 반응한다
4. `UsernamePasswordAuthenticationFilter`
    - 인증 객체를 생성하고 `AuthenticationManager`에게 인증을 맡김 → `AuthenticationProvider` 실질적인 인증의 검증 총괄(`UserDetailsService`)
    - 인증이 성공하면, `SecurityContextHolder`가 관리하는 `Authentication`객체에 [인증결과]를 담음
5. `SessionManagementFilter`와 함께
    - 인증 후 후속처리를 담당
    - 인증이 되었는데 동시 접근인지 판단한다던지(`ConcurrentSession`),
    - 인증을 성공한 시점에 이전 쿠키에 세션이 있으면 지우고, 새로 발급하여 세션이 연결되도록 하여(`SessionFixation`)
    - 결국 세션을 등록하게 된다(`RegisterSessionInfo`)

### 요청으로 들어온 자원 접근

1. `DelegatingFilterProxy` → `FilterChainProxy` → `SecurityContextPersistenceFilter` (위와 공통)
2. 통과 필터 목록
    - → `LogoutFilter` 
    → `UsrnamePasswordAuthenticationFilter` 
    → `ConcurrentSessionFilter` 
    → `RememberMeAuthenticationFilter`(현재 사용자가 세션 만료시, Session의 인증객체가 null인 경우에 발동) 
    → `AnonymousAuthenticationFilter`(익명 사용자의 인증 처리 여부가 필요할 시 적용, 익명사용자 인증토큰으로 인증객체를 사용)
    → `SessionManagementFilter`(조건이 있다, Session에 인증객체가 없거나 Session자체가 null인 경우)
3. ExceptionTranslationFilter (예외를 처리하는 필터) 
4. FilterSecurityInterceptor
    - 인증 객체를 가지고 있는지 ← 없으면 예외, 없으면 인가처리 자체도 불가능
    - 그 이후는 자원에 접근할 권한이 없거나, 요청 정보가 타당한지 여부를 판단

### 동일한 계정으로 인증을 시도하는 경우

1. `DelegatingFilterProxy` → `FilterChainProxy` → `SecurityContextPersistenceFilter` (위와 공통)
2. …`ConcurrentSessionFilter`까지 왔다
    - 이전 사용자 세션 1개가 있고 최대 1개만 가능한 경우
    - **전략1)** 사용자 인증 시도를 차단 → `SessionAuthenticationException` 던짐
    - **전략2)** 사용자 인증 시도는 허용하되, 이전 사용자 세션을 만료시킴 → `session.expireNow` 설정
        - 전략2의 경우, 이전 사용자 요청이 들어오면 `ConcurrentSessionFilter` 의 `session.isExpired`가 True로 판단되고 → logout된다
    -