# 유연한 함수를 만들어라

# 테스트하기 쉬운 함수를 작성하라

불러온 함수를 직접 사용할 때는 테스트 하려는 함수가 불러온 함수와 밀접하게 결합되는 문제가 발생

- 테스트를 위한 헬퍼를 사용해라
    - 스텁 - 외부 코드를 덮어 써서 명시적인 겨로가를 반환. 함수의 내부 논리를 모두 제거하고 결과만을 선언
    - 모의 객체 - 원본 객체를 대체한 후, 원본 객체가 수신할 메시지와 호출할 메서드를 바탕으로 단언문을 작성.
    - 스파이 - 모의객체와 비슷하지만, 코드를 실행한 후에 스파이가 어떻게 호출되었는지 확인함.

테스트에 헬퍼가 과도하게 사용된다면 코드가 복잡하고 강하게 결합되어 있다는 증거

밀접하게 결합된 코드에 DI를 적용하면 느슨한 결합이 될 수 있다.

# 화살 함수로 복잡도를 낮춰라

- 인수를 해체 할당하는 방법
    - JS엔진은 괄호가 없으면 객체 선언과 함수 선언을 구분하지 못한다. 객체와 같이 특별한 매개 변수를 사용할 때에는 괄호로 감싸라
- 객체를 반환하는 방법
    - 화살표 함수에서 화살표 우측의 중괄호는 객체를 나타내는 것인지 함수 몸체를 감싸는 것인지 구분하기 어렵기에 객체를 괄호로 감싸야한다.
    - 괄호를 사용해서 값을 반활할 때는 코드를 여러줄에 걸쳐 작성할 수 있다.
- 고차 함수를 만드는 방법
    - 고차함수는 그저 다른 함수를 반환하는 함수일 뿐
    - 함수 몸체에서 다른 함수를 반환하게 만들면 된다.
    - 고차 함수를 이용해 화살표 함수가 연속돼 있다면 첫번째 매개변수 바로 뒤에 괄호를 연결하면 두번째 매개변수를 호출할 수도 있다.

# 부분 적용 함수로 단일 책임 매개변수를 관리하라

- 부분 적용 함수로 매개변수를 집중시키는 방법
    - 고차 함수는 다른 함수를 반환하는 함수 → 최소한 두 단계에 걸친 매개변수가 존재
    - 괄호에 이어 다시 괄호를 사용하면 외부 함수를 호출 후 바로 내부 함수를 사용 가능하다.
    - 단일 책임을 부여함으로써 나머지 매개변수를 재사용할 수 있다.

# 커링과 배열 메서드를 조합한 부분 적용 함수를 사용하라

- 함수의 부분 적용을 통해 변수를 저장해 두는 방법
    - 고차 함수를 사용하면 값을 한 번 저장한 후 나중에 사용할 수 있는 새로운 함수를 만들어 반복을 피할 수 있다.
    - 마치 인수를 하드 코딩해둔 함수를 작성하는 것 과 같이 사용할 수 있다.
- 커링과 부분적용

| 커링 | 부분적용 |
| --- | --- |
| 여러개의 인수를 받는 함수에서 정확히 인수 하나만 받는 함수를 반환 | 원래의 함수보다 항수가 적은 함수를 반환 |
- 조건을 함수 매개변수로 받아 조건 역시 변동이 가능한 함수 제작이 가능하다.

# 화살표 함수로 문맥 혼동을 피하라

- 문맥은 함수 또는 클래스에서 this 키워드가 참조하는 것이다.
- 유효 범위는 함수와, 문맥은 객체와 연관되어 있다.

```jsx
const validator = {
	message: '는 유효하지 않습니다.',
	setInvalidMessages(...fields) {
		return fields.map(function (field){
			return `${field}${this.message}`
		}
	}
}
```

위 예제 함수를 호출하면 TypeError 또는 undefined를 받는다.

그 이유는 함수를 호출할 때 마다 호출되는 위치를 바탕으로 this 바인딩을 만드는데 setInvalidMessage는 객체를 문맥으로 해서 호출된다. 여기서 this의 문맥이 해당 객체이다. map() 메서드에 콜백 함수로 전달한 경우에는 map() 메서드의 문맥에서 호출되므로 이 경우에는 this 바인딩이 validator 객체가 아니다. 전연 객체가 된다. 브라우저에서는 window, Node.js REPL 환경에서는 global이 되는 것이다.

이 경우 화살표 함수를 호출한다면 this 바인딩을 새로 만들지 않아 의도대로 작동한다.

```jsx
const validator = {
	message: '는 유효하지 않습니다.',
	setInvalidMessages(...fields) {
		return fields.map(field => {
			return `${field}${this.message}`
		}
	}
}
```

화살표 함수는 이미 문맥이 있고 다른 함수 내부에서 이 함수를 사용하려고 할 때 유용하다.