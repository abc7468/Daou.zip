## Lambda로 Stream 간략화
```java
// Method 1
List<CompletableFuture<Void>> futures = recipients.stream()
		.map(id ->
			insertWeeklyReportContents(id).exceptionally(throwable -> {
				log.error("ERROR!", throwable);
			}))
		.collect(Collectors.toList());

// Method 2
List<CompletableFuture<Void>> futures = targets.stream()
		.map(id -> 
			sendWeeklyReportMail(weeklyId, id).exceptionally(throwable -> {
				log.error("ERROR!", throwable);
			}))
		.collect(Collectors.toList());
```

- 중요한 부분만 추출하자면...
```java
// Method 1
.map(id ->
	insertWeeklyReportContents(id).exceptionally(throwable -> {
		log.error("ERROR!", throwable);
	})
)

// Method 2
.map(id -> 
	sendWeeklyReportMail(weeklyId, id).exceptionally(throwable -> {
		log.error("ERROR!", throwable);
	})
)
```


## [Functional Interface](https://tecoble.techcourse.co.kr/post/2020-07-17-Functional-Interface/)와 1급 객체로써의 함수를 활용하여 코드 리팩터링
### BiFunction을 매개변수로 받는 Method `makeAsyncTask` 선언
```java
public List<CompletableFuture<Void>> makeAsyncTask(
		List<String> targets,
		String weeklyId,
		BiFunction<String, String, CompletableFuture<Void>> function,
		String taskName) {
		
	return targetTenants.stream()
			.map(id -> 
				function.apply(weeklyId, id).exceptionally(throwable -> {
					log.error("ERROR!", throwable);
				}))
			.collect(Collectors.toList());
```

### Lambda 부분을 조금 더 간략화 가능
```java
// Method 1
BiFunction<String, String, CompletableFuture<Void>> insertContents = (w, t) -> insertWeeklyReportContents(t);

List<CompletableFuture<Void>> futures = makeAsyncTasks(recipients, null, insertContents, INSERTION_CONTENTS);

// Method 2
BiFunction<String, String, CompletableFuture<Void>> sendMail = (w, t) -> sendWeeklyReportMail(w, t);

List<CompletableFuture<Void>> futures = makeAsyncTasks(targets, weeklyId, sendMail, SENDING_MAIL);
```

### BiFunction 간략화
```java
// Method 1
List<CompletableFuture<Void>> futures = makeAsyncTasks(recipients,
		weeklyId,
		(weekly, tenant) -> insertWeeklyReportContents(weekly, tenant),
		INSERTION_CONTENTS);

// Method 2
List<CompletableFuture<Void>> futures = makeAsyncTasks(targets,
		weeklyId,
		(weekly, tenant) -> sendWeeklyReportMail(weekly, tenant),
		SENDING_MAIL);
```

## Method Reference를 활용하여 코드 리팩터링
### "객체::메소드명" 형태로 메소드를 매개변수로 전달 가능
```java
// Method 1
List<CompletableFuture<Void>> futures = makeAsyncTasks(recipients,
		weeklyId,
		this::insertWeeklyReportContents,
		INSERTION_CONTENTS);

// Method 2
List<CompletableFuture<Void>> futures = makeAsyncTasks(targets,
		weeklyId,
		this::sendWeeklyReportMail,
		SENDING_MAIL);
```


## LocalDate (작성 중)
```java
private String getLastWeekDate(LocalDate inputDate, DayOfWeek weekDay) {
	DayOfWeek dayOfWeek = inputDate.getDayOfWeek();
	LocalDate monday = inputDate.minusDays(dayOfWeek.getValue() - 1).minusWeeks(1);

	return dateFormatter.format(monday.plusDays(weekDay.getValue() - 1));
}

private String getSendDate(LocalDate startDate) {
	List<String> candidateDates = Stream.iterate(startDate, date -> date.plusDays(1))
		.filter(this::isWeekday)
		.limit(30)
		.map(dateFormatter::format)
		.collect(Collectors.toList());

	return weeklyReportMapper.selectSendDate(candidateDates);
}

private boolean isWeekday(LocalDate date) {
	return date.getDayOfWeek() != DayOfWeek.SATURDAY && date.getDayOfWeek() != DayOfWeek.SUNDAY;
}
```




### 추가...
```java
// runAsync를 빼먹었습니다...
.map(id -> 
	 CompletableFuture.runAsync(() -> 
		 function.apply(weeklyId, id).exceptionally(throwable -> {
			log.error("ERROR!", throwable);
			})
		)
	)
```
